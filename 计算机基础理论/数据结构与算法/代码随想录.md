# 二叉树

## 基础遍历

### 迭代遍历

#### 前序

遍历顺序：中左右

栈逻辑：出中  非空入右左

过程：

1. 将根节点入栈，开始迭代处理
2. 当栈不空时
   1. 出栈，处理逻辑
   2. 非空入栈右节点
   3. 非空入栈左节点

#### 中序

遍历顺序：左中右

栈逻辑：空出更为右  非入更为左  条件有二

过程：

1. 当前节点cur指向根节点
2. 当cur非空或栈非空
   1. 如果cur==null：出栈，处理逻辑，cur置为出栈节点的右节点
   2. 如果cur!=null：入栈，cur置为cur的左节点

### 层次遍历

使用队列模拟

<font color=red>一个区分/记录层次的技巧：</font>

​	在处理每一层之前，先把当前队列长度len存起来，此时len便是该层的节点数；然后出队len次进入下一层处理

## 递归考虑

### 函数签名

**返回值**

递归函数什么时候需要返回值？什么时候不需要返回值？这里总结如下三点：

- 如果需要搜索整棵二叉树且不用处理递归返回值，递归函数就不要返回值。（113.路径总和ii）
- 如果需要搜索整棵二叉树且需要处理递归返回值，递归函数就需要返回值。 （236. 二叉树的最近公共祖先）
- 如果要搜索其中一条符合条件的路径，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。（112路径总和）

**终止条件**

- 正常需要遍历整棵树，遇到空子树便返回上一层递归
- 其他情况（提前终止，然后返回上一层）
  - 叶子节点
  - 满足条件的节点

**单层递归逻辑**

呈现遍历顺序的地方

- 递归左子树<font color=red>左</font>

- 递归右子树<font color=red>右</font>

- 当前节点的处理逻辑<font color=red>中</font>

  其实终止条件也属于这个范畴，因为每次处理当前节点之前都要判断是否已经需要终止

### 后序

后序体现了分治的思想

特征：当前节点的处理逻辑（结果）依赖于左右子树的处理结果。所以该递归一般是带有返回值的

- 对称二叉树

  判断以当前左右两节点为根的两颗树对称，结果依赖于左节点的左子树与右节点的右子树是否对称，以及左节点的右子树与右节点的左子树是否对称的<font color=red>布尔结果</font>

- 二叉树最大深度（根节点的最大高度）

  需要得到当前节点的最大高度，结果依赖于该节点的左右子树的最大高度的<font color=red>较大值</font>

- 二叉树最小深度（根节点的最小高度）

  需要得到当前节点的最小高度，结果依赖于该节点左右子树的最小高度的<font color=red>较小值</font>

  与求最大高度不同的是，当只有一边子树的最小高度大于0，较小的0要被舍去，因为该子树为空，不存在叶子节点

- 二叉树节点数

  当前节点为根的树的节点树等于1+左子树节点数和右子树节点数<font color=red>之和</font>

- 平衡二叉树

  判断当前节点的树是否平衡，需要计算左右子树的高度<font color=red>之差</font>，同时需要左右子树是否各平衡的<font color=red>布尔结果</font>

- 左节点之和

  当前节点的树的左节点之和，等于左右子树的左节点<font color=red>之和</font>

- 任意两节点的最近公共祖先

  要判断当前节点是否为节点a、b的最近公共祖先，需要判断左右子树是否<font color=red>分别为</font>a、b的祖先

### 前序（回溯）

**一般前序**

特征：需要先确定或处理根节点，才能确定或处理左右子树。在构建树的情境下一般选择前序

- 数组构造二叉树

  思路都是先确定中间节点，然后找到左右子树的数组区间

  - 前序+中序
  - 后序+中序
  - 完全二叉树数组构建
  - 最大的二叉树

- 合并两个二叉树

  两棵树同时前序遍历，一颗为主，一颗为辅。主辅都不空合并；主左为空，辅左挂上；主右为空，辅右挂上

**回溯风格**

特征：需要走到尽头（叶子节点）或满足条件的点才能得到一个最终结果，而且最终结果需要在前面层的子结果上做拓展

- 二叉树的所有路径

  传递的子结果：从根节点到当前节点的子路径

- 最小深度（根节点最小高度）

  传递的子结果：当前节点的深度

- 路径总和

  传递的子结果：目标和减去从根节点到当前节点的总和（到当前节点时还需要多少能达到目标）

- 左下角的值

  传递的子结果：当前节点的深度

### 中序

特征：结果依赖流是这样的<font color=red>左->中->右</font>或者<font color=red>右->中->左</font>

- 538 累加树

  需要记录前继节点的值（等于处理完前继节点时的雷剑值）。在处理当前节点的时候，将前继节点的值累加到当前节点的值中作为当前节点新的值



## 二叉搜索树

### 最近公共祖先

二叉搜索树的特殊性，只需要先序遍历找到第一个位于区间[a,b]的节点便是最近公共祖先

### 插入

前序遍历：因为需要根据当前节点的情况去决定向左还是向右递归

### 删除

一个重要的操作：<font color=red>找到要删除节点的右子树最小值</font>

**要删除节点的右节点**作为新的根

1. 迭代找到右子树最小值的节点cur
2. 将要删除节点的左子树挂在cur的左边
3. 返回要删除节点的右节点作为新的根

### 修剪

前序遍历：因为需要根据当前节点的值和要修剪区间的关系决定下一步的递归

​	如果当前节点的值在区间左边，则返回递归处理右子树的结果

​	如果当前节点的值在区间右边，则返回递归处理左子树的结果

​	如果当前节点的值位于区间内（包括边界），保留当前节点，左子树为递归处理的左子树，右子树为递归处理的右子树

### 中序（需要基于升序序列做统计）

<font color=red>重点：</font>需要记录**前继**节点

- 验证二叉搜索树

  中序遍历，需要记录前继节点。在单层递归处理的时候，比较当前节点的值是否大于前继节点的值。如果不满足则返回false

- 最小差值

  中序遍历，需要记录前继节点和当前最小差值。在单层递归处理的时候，判断是否需要更新最小差值

- 众数（可能有多个）

  中序遍历，需要记录前继节点、过程结果表、当前count和当前最大maxcount。在单层递归处理的时候，如果当前节点和前继节点的值相等，count加一；如果此时count达到maxcount则将当前值加入过程结果表；如果此时count大于maxcount，先将过程结果表清空再加入当前值。

## 迭代

迭代囊括四种遍历方式

一般情况下，递归使用了哪种遍历方式，迭代就选用哪种方式，又或者是层次遍历会特别适合

### 回溯$\rightarrow$迭代

需要使用额外的栈保存中间子结果