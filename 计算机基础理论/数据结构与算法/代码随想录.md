# 数组

## 二分查找

### golang二分查找API

```go
nums:=[]int{1,3,4,7,9}
//sort.Search(n int,func(index int)bool) int
//索引从0开始，n为右开区间 [0...n)
//返回满足布尔函数的第一个下标
sort.Search(len(nums),func(index int)bool{
    return nums[index]>=4//这里返回在数组nums里，第一个满足大于等于4的小标，所以这里返回'2'
})
```

### 二分答案

[2616. 最小化数对的最大差值 - 力扣（LeetCode）](https://leetcode.cn/problems/minimize-the-maximum-difference-of-pairs/)

我们需要在潜在答案集 [0...X..max]中找到目标X

可以将数组分为三部分【“<p区间”，“ =p区间”，“ >p区间”】

X就是“=p区间”里的第一个

 [0...max]是有序的，可以使用<font color=red>二分查找</font>

检查mid，它对应的满足差值大于等于mid的数对的数量为y

若y>=p检查[0...mid]

若y<p检查[mid+1...max]

```go
func minimizeMax(nums []int, p int) int {
    sort.Ints(nums)
	return sort.Search(nums[len(nums)-1]-nums[0], func(mx int) bool {
		cnt := 0
		for i := 0; i < len(nums)-1; i++ {
			if nums[i+1]-nums[i] <= mx {
				cnt++
				i++
			}
		}
		return cnt >= p
	})

}
```

## 双指针&快慢指针



[27. 移除元素 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-element/)

**快慢指针**

`i`：慢指针，指向当前目标数组末尾的下一位，接收新数组的位置

`j`：快指针：用来遍历的指针

```go
func removeElement(nums []int, val int) int {
    i,j:=0,0
    for j<len(nums){
        //检查nums[j]，不等于val则让i位置接收
        if nums[j]!=val{
            nums[i]=nums[j]
            i++
        }
        j++
    }
    return i

}
```



[977. 有序数组的平方 - 力扣（LeetCode）](https://leetcode.cn/problems/squares-of-a-sorted-array/)

**双指针**

平方大的数一定在两端

```go
func sortedSquares(nums []int) []int {
    n:=len(nums)
    res:=make([]int,n)
    i,j:=0,n-1
    k:=n-1
    for i<j {
        if nums[i]*nums[i]>nums[j]*nums[j]{
            res[k]=nums[i]*nums[i]
            i++
        }else{
            res[k]=nums[j]*nums[j]
            j--
        }
        k--
    }
    res[0]=nums[i]*nums[i]
    return res
}
```



## 滑动窗口

```go
func minSubArrayLen(target int, nums []int) int {
    l,r:=0,0
    _min:=len(nums)+1
    sum:=0
    for r<len(nums)&&l<=r {
        sum+=nums[r]
        for sum>=target&&l<=r{
            _min=min(_min,r-l+1)
            sum-=nums[l]
            l++
        }
        r++
    }
    if _min==len(nums)+1 {
        return 0
    }
    return _min

}
func min(a,b int)int{
    if a<b{
        return a
    }
    return b
}
```

## 二维数组模拟



[59. 螺旋矩阵 II - 力扣（LeetCode）](https://leetcode.cn/problems/spiral-matrix-ii/)

维护四个边界，模拟右下左上旋转，每当一个方向走到尽头，肯定有其中一个边界需要缩小

```go
func generateMatrix(n int) [][]int {

    matrix := make([][]int, n)
	for i := 0; i < n; i++ {
		matrix[i] = make([]int, n)
	}
	left, right, up, down := 0, n-1, 0, n-1
	m := 1
	for m <= n*n {
		//turn right
		for i := left; i <= right; i++ {
			matrix[up][i] = m
			m++
		}
		up++
		//turn down
		for i := up; i <= down; i++ {
			matrix[i][right] = m
			m++
		}
		right--
		//turn left
		for i := right; i >= left; i-- {
			matrix[down][i] = m
			m++
		}
		down--
		//turn up
		for i := down; i >= up; i-- {
			matrix[i][left] = m
			m++
		}
		left++
	}
	return matrix

}
```



# 链表

[206. 反转链表 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-linked-list/)

**无空头节点**

从左到右，一个个地将右箭头变成左箭头

p->q->r $\Rightarrow$ p<-q  r

可以看到r会断裂，所以需要用临时指针保护r

```go
func reverseList(head *ListNode) *ListNode {

    var pre *ListNode
    cur:=head
    for cur!=nil{
        temp:=cur.Next
        cur.Next=pre
        pre=cur
        cur=temp
    }
    return pre

}
```

**使用辅助头节点**

直接头插法



[24. 两两交换链表中的节点 - 力扣（LeetCode）](https://leetcode.cn/problems/swap-nodes-in-pairs/)



# 字符串



# 双指针



# 二叉树

## 基础遍历

### 迭代遍历

#### 前序

遍历顺序：中左右

栈逻辑：出中  非空入右左

过程：

1. 将根节点入栈，开始迭代处理
2. 当栈不空时
   1. 出栈，处理逻辑
   2. 非空入栈右节点
   3. 非空入栈左节点

#### 中序

遍历顺序：左中右

栈逻辑：空出更为右  非入更为左  条件有二

过程：

1. 当前节点cur指向根节点
2. 当cur非空或栈非空
   1. 如果cur==null：出栈，处理逻辑，cur置为出栈节点的右节点
   2. 如果cur!=null：入栈，cur置为cur的左节点

### 层次遍历

使用队列模拟

<font color=red>一个区分/记录层次的技巧：</font>

​	在处理每一层之前，先把当前队列长度len存起来，此时len便是该层的节点数；然后出队len次进入下一层处理

## 递归考虑

### 函数签名

**返回值**

递归函数什么时候需要返回值？什么时候不需要返回值？这里总结如下三点：

- 如果需要搜索整棵二叉树且不用处理递归返回值，递归函数就不要返回值。（113.路径总和ii）
- 如果需要搜索整棵二叉树且需要处理递归返回值，递归函数就需要返回值。 （236. 二叉树的最近公共祖先）
- 如果要搜索其中一条符合条件的路径，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。（112路径总和）

**终止条件**

- 正常需要遍历整棵树，遇到空子树便返回上一层递归
- 其他情况（提前终止，然后返回上一层）
  - 叶子节点
  - 满足条件的节点

**单层递归逻辑**

呈现遍历顺序的地方

- 递归左子树<font color=red>左</font>

- 递归右子树<font color=red>右</font>

- 当前节点的处理逻辑<font color=red>中</font>

  其实终止条件也属于这个范畴，因为每次处理当前节点之前都要判断是否已经需要终止

### 后序

后序体现了分治的思想

特征：当前节点的处理逻辑（结果）依赖于左右子树的处理结果。所以该递归一般是带有返回值的

- 对称二叉树

  判断以当前左右两节点为根的两颗树对称，结果依赖于左节点的左子树与右节点的右子树是否对称，以及左节点的右子树与右节点的左子树是否对称的<font color=red>布尔结果</font>

- 二叉树最大深度（根节点的最大高度）

  需要得到当前节点的最大高度，结果依赖于该节点的左右子树的最大高度的<font color=red>较大值</font>

- 二叉树最小深度（根节点的最小高度）

  需要得到当前节点的最小高度，结果依赖于该节点左右子树的最小高度的<font color=red>较小值</font>

  与求最大高度不同的是，当只有一边子树的最小高度大于0，较小的0要被舍去，因为该子树为空，不存在叶子节点

- 二叉树节点数

  当前节点为根的树的节点树等于1+左子树节点数和右子树节点数<font color=red>之和</font>

- 平衡二叉树

  判断当前节点的树是否平衡，需要计算左右子树的高度<font color=red>之差</font>，同时需要左右子树是否各平衡的<font color=red>布尔结果</font>

- 左节点之和

  当前节点的树的左节点之和，等于左右子树的左节点<font color=red>之和</font>

- 任意两节点的最近公共祖先

  要判断当前节点是否为节点a、b的最近公共祖先，需要判断左右子树是否<font color=red>分别为</font>a、b的祖先

### 前序（回溯）

**一般前序**

特征：需要先确定或处理根节点，才能确定或处理左右子树。在构建树的情境下一般选择前序

- 数组构造二叉树

  思路都是先确定中间节点，然后找到左右子树的数组区间

  - 前序+中序
  - 后序+中序
  - 完全二叉树数组构建
  - 最大的二叉树

- 合并两个二叉树

  两棵树同时前序遍历，一颗为主，一颗为辅。主辅都不空合并；主左为空，辅左挂上；主右为空，辅右挂上

**回溯风格**

特征：需要走到尽头（叶子节点）或满足条件的点才能得到一个最终结果，而且最终结果需要在前面层的子结果上做拓展

- 二叉树的所有路径

  传递的子结果：从根节点到当前节点的子路径

- 最小深度（根节点最小高度）

  传递的子结果：当前节点的深度

- 路径总和

  传递的子结果：目标和减去从根节点到当前节点的总和（到当前节点时还需要多少能达到目标）

- 左下角的值

  传递的子结果：当前节点的深度

### 中序

特征：结果依赖流是这样的<font color=red>左->中->右</font>或者<font color=red>右->中->左</font>

- 538 累加树

  需要记录前继节点的值（等于处理完前继节点时的雷剑值）。在处理当前节点的时候，将前继节点的值累加到当前节点的值中作为当前节点新的值



## 二叉搜索树

### 最近公共祖先

二叉搜索树的特殊性，只需要先序遍历找到第一个位于区间[a,b]的节点便是最近公共祖先

### 插入

前序遍历：因为需要根据当前节点的情况去决定向左还是向右递归

### 删除

一个重要的操作：<font color=red>找到要删除节点的右子树最小值</font>

**要删除节点的右节点**作为新的根

1. 迭代找到右子树最小值的节点cur
2. 将要删除节点的左子树挂在cur的左边
3. 返回要删除节点的右节点作为新的根

### 修剪

前序遍历：因为需要根据当前节点的值和要修剪区间的关系决定下一步的递归

​	如果当前节点的值在区间左边，则返回递归处理右子树的结果

​	如果当前节点的值在区间右边，则返回递归处理左子树的结果

​	如果当前节点的值位于区间内（包括边界），保留当前节点，左子树为递归处理的左子树，右子树为递归处理的右子树

### 中序（需要基于升序序列做统计）

<font color=red>重点：</font>需要记录**前继**节点

- 验证二叉搜索树

  中序遍历，需要记录前继节点。在单层递归处理的时候，比较当前节点的值是否大于前继节点的值。如果不满足则返回false

- 最小差值

  中序遍历，需要记录前继节点和当前最小差值。在单层递归处理的时候，判断是否需要更新最小差值

- 众数（可能有多个）

  中序遍历，需要记录前继节点、过程结果表、当前count和当前最大maxcount。在单层递归处理的时候，如果当前节点和前继节点的值相等，count加一；如果此时count达到maxcount则将当前值加入过程结果表；如果此时count大于maxcount，先将过程结果表清空再加入当前值。

## 迭代

迭代囊括四种遍历方式

一般情况下，递归使用了哪种遍历方式，迭代就选用哪种方式，又或者是层次遍历会特别适合

### 回溯$\rightarrow$迭代

需要使用额外的栈保存中间子结果



# 单调栈&单调队列



# 回溯



# 动态规划

