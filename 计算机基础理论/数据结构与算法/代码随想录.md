# 数组

## 二分查找

### golang二分查找API

```go
nums:=[]int{1,3,4,7,9}
//sort.Search(n int,func(index int)bool) int
//索引从0开始，n为右开区间 [0...n)
//返回满足布尔函数的第一个下标
sort.Search(len(nums),func(index int)bool{
    return nums[index]>=4//这里返回在数组nums里，第一个满足大于等于4的小标，所以这里返回'2'
})
```

### 二分答案

[2616. 最小化数对的最大差值 - 力扣（LeetCode）](https://leetcode.cn/problems/minimize-the-maximum-difference-of-pairs/)

我们需要在潜在答案集 [0...X..max]中找到目标X

可以将数组分为三部分【“<p区间”，“ =p区间”，“ >p区间”】

X就是“=p区间”里的第一个

 [0...max]是有序的，可以使用<font color=red>二分查找</font>

检查mid，它对应的满足差值大于等于mid的数对的数量为y

若y>=p检查[0...mid]

若y<p检查[mid+1...max]

```go
func minimizeMax(nums []int, p int) int {
    sort.Ints(nums)
	return sort.Search(nums[len(nums)-1]-nums[0], func(mx int) bool {
		cnt := 0
		for i := 0; i < len(nums)-1; i++ {
			if nums[i+1]-nums[i] <= mx {
				cnt++
				i++
			}
		}
		return cnt >= p
	})

}
```





## 二维数组模拟



[59. 螺旋矩阵 II - 力扣（LeetCode）](https://leetcode.cn/problems/spiral-matrix-ii/)

维护四个边界，模拟右下左上旋转，每当一个方向走到尽头，肯定有其中一个边界需要缩小

```go
func generateMatrix(n int) [][]int {

    matrix := make([][]int, n)
	for i := 0; i < n; i++ {
		matrix[i] = make([]int, n)
	}
	left, right, up, down := 0, n-1, 0, n-1
	m := 1
	for m <= n*n {
		//turn right
		for i := left; i <= right; i++ {
			matrix[up][i] = m
			m++
		}
		up++
		//turn down
		for i := up; i <= down; i++ {
			matrix[i][right] = m
			m++
		}
		right--
		//turn left
		for i := right; i >= left; i-- {
			matrix[down][i] = m
			m++
		}
		down--
		//turn up
		for i := down; i >= up; i-- {
			matrix[i][left] = m
			m++
		}
		left++
	}
	return matrix

}
```



# 链表

## 反转链表

[206. 反转链表 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-linked-list/)

**无空头节点**

从左到右，一个个地将右箭头变成左箭头

p->q->r $\Rightarrow$ p<-q  r

可以看到r会断裂，所以需要用临时指针保护r

```go
func reverseList(head *ListNode) *ListNode {

    var pre *ListNode
    cur:=head
    for cur!=nil{
        temp:=cur.Next
        cur.Next=pre
        pre=cur
        cur=temp
    }
    return pre

}
```

**使用辅助头节点**

直接头插法

## 两两交换结点

[24. 两两交换链表中的节点 - 力扣（LeetCode）](https://leetcode.cn/problems/swap-nodes-in-pairs/)



```go
func swapPairs(head *ListNode) *ListNode {
	dummyHead := new(ListNode)
	dummyHead.Next = head
	cur := dummyHead
	for cur.Next != nil && cur.Next.Next != nil {
		//第一步丢失1，第二步丢失3，所以要先维护1，3
		temp1 := cur.Next
		temp2 := cur.Next.Next.Next
		//三步走
		cur.Next = cur.Next.Next
		cur.Next.Next = temp1
		cur.Next.Next.Next = temp2
		//0向前走两步，成为新的终点
		cur = cur.Next.Next
	}
	return dummyHead.Next
}

```

## 删除倒数第N个结点

[19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/)

**快慢指针**

使用虚拟头，从虚拟头出发，快指针先走N+1步，当快指针到末尾时，慢指针刚好落在倒数第N+1的位置

```go
func removeNthFromEnd(head *ListNode, n int) *ListNode {
    dummyHead:=new(ListNode)
    dummyHead.Next=head
    l,r:=dummyHead,dummyHead
    for i:=0;i<=n;i++{
        r=r.Next
    }
    for r!=nil{
        l=l.Next
        r=r.Next
    }
    l.Next=l.Next.Next
    return dummyHead.Next

}
```

## 环形链表

[142. 环形链表 II - 力扣（LeetCode）](https://leetcode.cn/problems/linked-list-cycle-ii/)

**判断是否有环**

快慢指针

1. 从虚拟头出发，快指针每次两步，慢指针每次一步，相遇则有环
2. start0从虚拟头出发，start1从快慢指针相遇的地方出发，start0和start1相遇的地方就是环入口

```go
func detectCycle(head *ListNode) *ListNode {
    dummyHead:=new(ListNode)
    dummyHead.Next=head
    s,f:=dummyHead,dummyHead
    start0:=dummyHead
    var start1 *ListNode
    for f!=nil&&f.Next!=nil{
        s=s.Next
        f=f.Next.Next
        if s==f {
            start1=s
            break
        }
    }
    if start1==nil {
        return nil
    }
    
    for start0!=start1 {
        start0=start0.Next
        start1=start1.Next
    }
    return start0
    
}
```



# 字符串



# 双指针

## 移除数组元素

[27. 移除元素 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-element/)

**快慢指针**

`i`：慢指针，指向当前目标数组末尾的下一位，接收新数组的位置

`j`：快指针：用来遍历的指针

```go
func removeElement(nums []int, val int) int {
    i,j:=0,0
    for j<len(nums){
        //检查nums[j]，不等于val则让i位置接收
        if nums[j]!=val{
            nums[i]=nums[j]
            i++
        }
        j++
    }
    return i

}
```

## 有序数组平方序

[977. 有序数组的平方 - 力扣（LeetCode）](https://leetcode.cn/problems/squares-of-a-sorted-array/)

**双指针**

平方大的数一定在两端

```go
func sortedSquares(nums []int) []int {
    n:=len(nums)
    res:=make([]int,n)
    i,j:=0,n-1
    k:=n-1
    for i<j {
        if nums[i]*nums[i]>nums[j]*nums[j]{
            res[k]=nums[i]*nums[i]
            i++
        }else{
            res[k]=nums[j]*nums[j]
            j--
        }
        k--
    }
    res[0]=nums[i]*nums[i]
    return res
}
```



## 三数之和

固定a，双指针分别指向b，c；大了c往左走，小了b往右走，相等则将结果加入

三个指针都需要去重：

- a指针去重：只有第一次进入a操作，后面所有相等的a都跳过操作
- b，c去重：找到一个答案后，需要跳过当前所有相等的b和c

```go
func threeSum(nums []int) [][]int {
    sort.Ints(nums)
	if nums[0] > 0 {
		return nil
	}
	res:=[][]int{}
	n:=len(nums)
	for i := 0; i < n; i++ {
		//第一重
		if i>0&&nums[i]==nums[i-1]{
			continue
		}
		l,r:=i+1,n-1
		for l < r {
			t:=nums[l]+nums[r]+nums[i]
			if t>0 {
				r--
			}else if t<0 {
				l++
			}else {
				res= append(res, []int{nums[i], nums[l], nums[r]})
				x,y:=nums[l],nums[r]
				//第二第三重
				for l<r&&nums[l]==x {
					l++
				}
				for l<r&&nums[r]==y {
					r--
				}
			}
		}
	}
	return res

}
```

# 滑动窗口

一般都与<font color=red>连续字串、连续子数组</font>等有关



## 子数组

[209. 长度最小的子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-size-subarray-sum/description/)

```go
func minSubArrayLen(target int, nums []int) int {
    l,r:=0,0
    _min:=len(nums)+1
    sum:=0
    for r<len(nums)&&l<=r {
        sum+=nums[r]
        for sum>=target&&l<=r{
            _min=min(_min,r-l+1)
            sum-=nums[l]
            l++
        }
        r++
    }
    if _min==len(nums)+1 {
        return 0
    }
    return _min

}
func min(a,b int)int{
    if a<b{
        return a
    }
    return b
}
```

## 子串

[3. 无重复字符的最长子串 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/)

```go
func lengthOfLongestSubstring(s string) int {

    lastOccurt := make(map[byte]int)
	start, maxLen := 0, 0
	for i, ch := range []byte(s) {
		if lastID, ok := lastOccurt[ch]; ok && lastID >= start {
			start = lastID + 1
		}
		if i-start+1 > maxLen {
			maxLen = i - start + 1
		}
		lastOccurt[ch] = i
	}
	return maxLen
}
```



# 二叉树

## 基础遍历

### 迭代遍历

#### 前序

遍历顺序：中左右

栈逻辑：出中  非空入右左

过程：

1. 将根节点入栈，开始迭代处理
2. 当栈不空时
   1. 出栈，处理逻辑
   2. 非空入栈右节点
   3. 非空入栈左节点

#### 中序

遍历顺序：左中右

栈逻辑：空出更为右  非入更为左  条件有二

过程：

1. 当前节点cur指向根节点
2. 当cur非空或栈非空
   1. 如果cur==null：出栈，处理逻辑，cur置为出栈节点的右节点
   2. 如果cur!=null：入栈，cur置为cur的左节点

### 层次遍历

使用队列模拟

<font color=red>一个区分/记录层次的技巧：</font>

​	在处理每一层之前，先把当前队列长度len存起来，此时len便是该层的节点数；然后出队len次进入下一层处理

## 递归考虑

### 函数签名

**返回值**

递归函数什么时候需要返回值？什么时候不需要返回值？这里总结如下三点：

- 如果需要搜索整棵二叉树且不用处理递归返回值，递归函数就不要返回值。（113.路径总和ii）
- 如果需要搜索整棵二叉树且需要处理递归返回值，递归函数就需要返回值。 （236. 二叉树的最近公共祖先）
- 如果要搜索其中一条符合条件的路径，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。（112路径总和）

**终止条件**

- 正常需要遍历整棵树，遇到空子树便返回上一层递归
- 其他情况（提前终止，然后返回上一层）
  - 叶子节点
  - 满足条件的节点

**单层递归逻辑**

呈现遍历顺序的地方

- 递归左子树<font color=red>左</font>

- 递归右子树<font color=red>右</font>

- 当前节点的处理逻辑<font color=red>中</font>

  其实终止条件也属于这个范畴，因为每次处理当前节点之前都要判断是否已经需要终止

### 后序

后序体现了分治的思想

特征：当前节点的处理逻辑（结果）依赖于左右子树的处理结果。所以该递归一般是带有返回值的

- 对称二叉树

  判断以当前左右两节点为根的两颗树对称，结果依赖于左节点的左子树与右节点的右子树是否对称，以及左节点的右子树与右节点的左子树是否对称的<font color=red>布尔结果</font>

- 二叉树最大深度（根节点的最大高度）

  需要得到当前节点的最大高度，结果依赖于该节点的左右子树的最大高度的<font color=red>较大值</font>

- 二叉树最小深度（根节点的最小高度）

  需要得到当前节点的最小高度，结果依赖于该节点左右子树的最小高度的<font color=red>较小值</font>

  与求最大高度不同的是，当只有一边子树的最小高度大于0，较小的0要被舍去，因为该子树为空，不存在叶子节点

- 二叉树节点数

  当前节点为根的树的节点树等于1+左子树节点数和右子树节点数<font color=red>之和</font>

- 平衡二叉树

  判断当前节点的树是否平衡，需要计算左右子树的高度<font color=red>之差</font>，同时需要左右子树是否各平衡的<font color=red>布尔结果</font>

- 左节点之和

  当前节点的树的左节点之和，等于左右子树的左节点<font color=red>之和</font>

- 任意两节点的最近公共祖先

  要判断当前节点是否为节点a、b的最近公共祖先，需要判断左右子树是否<font color=red>分别为</font>a、b的祖先

### 前序（回溯）

**一般前序**

特征：需要先确定或处理根节点，才能确定或处理左右子树。在构建树的情境下一般选择前序

- 数组构造二叉树

  思路都是先确定中间节点，然后找到左右子树的数组区间

  - 前序+中序
  - 后序+中序
  - 完全二叉树数组构建
  - 最大的二叉树

- 合并两个二叉树

  两棵树同时前序遍历，一颗为主，一颗为辅。主辅都不空合并；主左为空，辅左挂上；主右为空，辅右挂上

**回溯风格**

特征：需要走到尽头（叶子节点）或满足条件的点才能得到一个最终结果，而且最终结果需要在前面层的子结果上做拓展

- 二叉树的所有路径

  传递的子结果：从根节点到当前节点的子路径

- 最小深度（根节点最小高度）

  传递的子结果：当前节点的深度

- 路径总和

  传递的子结果：目标和减去从根节点到当前节点的总和（到当前节点时还需要多少能达到目标）

- 左下角的值

  传递的子结果：当前节点的深度

### 中序

特征：结果依赖流是这样的<font color=red>左->中->右</font>或者<font color=red>右->中->左</font>

- 538 累加树

  需要记录前继节点的值（等于处理完前继节点时的雷剑值）。在处理当前节点的时候，将前继节点的值累加到当前节点的值中作为当前节点新的值



## 二叉搜索树

### 最近公共祖先

二叉搜索树的特殊性，只需要先序遍历找到第一个位于区间[a,b]的节点便是最近公共祖先

### 插入

前序遍历：因为需要根据当前节点的情况去决定向左还是向右递归

### 删除

一个重要的操作：<font color=red>找到要删除节点的右子树最小值</font>

**要删除节点的右节点**作为新的根

1. 迭代找到右子树最小值的节点cur
2. 将要删除节点的左子树挂在cur的左边
3. 返回要删除节点的右节点作为新的根

### 修剪

前序遍历：因为需要根据当前节点的值和要修剪区间的关系决定下一步的递归

​	如果当前节点的值在区间左边，则返回递归处理右子树的结果

​	如果当前节点的值在区间右边，则返回递归处理左子树的结果

​	如果当前节点的值位于区间内（包括边界），保留当前节点，左子树为递归处理的左子树，右子树为递归处理的右子树

### 中序（需要基于升序序列做统计）

<font color=red>重点：</font>需要记录**前继**节点

- 验证二叉搜索树

  中序遍历，需要记录前继节点。在单层递归处理的时候，比较当前节点的值是否大于前继节点的值。如果不满足则返回false

- 最小差值

  中序遍历，需要记录前继节点和当前最小差值。在单层递归处理的时候，判断是否需要更新最小差值

- 众数（可能有多个）

  中序遍历，需要记录前继节点、过程结果表、当前count和当前最大maxcount。在单层递归处理的时候，如果当前节点和前继节点的值相等，count加一；如果此时count达到maxcount则将当前值加入过程结果表；如果此时count大于maxcount，先将过程结果表清空再加入当前值。

## 迭代

迭代囊括四种遍历方式

一般情况下，递归使用了哪种遍历方式，迭代就选用哪种方式，又或者是层次遍历会特别适合





# 回溯



# 动态规划

<font color=red>重叠子问题</font>

## 基础

**入门**

- 斐波那契数列
- 爬楼梯

**基础（dp定义清晰）**

| 题目                 | link                                                         | dp定义                         | 转移                                     |
| -------------------- | ------------------------------------------------------------ | ------------------------------ | ---------------------------------------- |
| 不同路径、不同路径II | [63. 不同路径 II - 力扣（LeetCode）](https://leetcode.cn/problems/unique-paths-ii/description/) | dp[i,j]：到达(i,j)的路径数     | dp[i,j]=dp[i-1,j]+dp[i,j-1]              |
| 整数拆分             | [343. 整数拆分 - 力扣（LeetCode）](https://leetcode.cn/problems/integer-break/description/) | dp[k]：拆分整数k所得的最大乘积 | dp[k]=max(k,dp[k-i]\*i,j*(k-j)) when k<n |
|                      |                                                              |                                |                                          |

**中等**

定义dp[j]的时候有两个维度

- to here or end with here
- true or false or  multi states





|                         | 数据结构 | dp定义                                                       | 转移                                                         | here    | states         |
| :---------------------- | :------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :------ | :------------- |
| 打家劫舍、打家劫舍II    | 一维数组 | dp[i]：考虑从0到i的最大值                                    | dp[i]=max(dp[i-1],dp[i-2]+value[i])                          | to here | true or false  |
| 股票1（一次买卖）       | 一位数组 | dp[i]\[0]：买入状态 dp[i]\[1]:卖出状态                       | dp[i]\[0]=max(dp[i-1]\[0]，-price[i])  dp[i]\[1]=max(dp[i-1]\[1],dp[i-1]\[0]+price[i]) | to here | true and false |
| 股票2（无限制次数买卖） |          | dp[i]\[0]：买入状态 dp[i]\[1]:卖出状态                       | dp[i]\[0]=max(dp[i-1]\[0]，dp[i-1]\[1]-price[i])  dp[i]\[1]=max(dp[i-1]\[1],dp[i-1]\[0]+price[i]) | to here | true and false |
| 股票3（两次买卖）       |          | dp[i]\[0]：第一次买入状态 dp[i]\[1]:第一次卖出状态  dp[i]\[2]：第二次买入状态 dp[i]\[3]:第二次卖出状态 | dp[i]\[0]=max(dp[i-1]\[0]，-price[i])  dp[i]\[1]=max(dp[i-1]\[1],dp[i-1]\[0]+price[i])   dp[i]\[2]=max(dp[i-1]\[2]，dp[i-1]\[1]-price[i])  dp[i]\[3]=max(dp[i-1]\[3],dp[i-1]\[2]+price[i]) | to here | multi states   |
| 股票4（m次买卖）        |          | 2m种状态                                                     | 状态从0到2m-1，写出股票三的规律便可   dp[i]\[j + 1] = max(dp[i - 1]\[j + 1], dp[i - 1]\[j] - prices[i]);                 dp[i]\[j + 2] = max(dp[i - 1]\[j + 2], dp[i - 1]\[j + 1] + prices[i]) | to here | multi states   |
| 股票含冷冻期            |          | 四种状态  dp[i]\[0]：买入状态 dp[i]\[1]:今天卖出状态  dp[i]\[2]：冷冻期  dp[i]\[3] 冷静期之后的持续卖出状态 | dp[i]\[0]=max(dp[i-1]\[0],max(dp[i-1]\[2],dp[i-1]\[3])-price[i])  dp[i]\[1]=dp[i-1]\[0]+price[i])   dp[i]\[2]=dp[i-1]\[1]  dp[i]\[3]=max(dp[i-1]\[2],dp[i-1]\[3]) | to here | multi states   |
|                         |          |                                                              |                                                              |         |                |



|             | 数据结构 | dp定义                                                       | 转移                                                         | here    | states         |
| :---------- | :------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :------ | :------------- |
| 打家劫舍III | 树状     | node.dp[0]：以node为根的树中，选取node的最大值                                                  node.dp[1]：以node 为根的树中，不选取node的最大值 | node.dp[0]=nodeLeft.dp[1]+nodeRight.dp[1] +node.value node.dp[1]=max(nodeLeft.dp[0],nodeLeft.dp[1])+max(nodeRight.dp[0],nodeRight.dp[1]) | up here | true and false |

# 高级数据结构

## 单调栈

<font color=red>单调栈维护从栈顶到栈底的元素呈递增或递减</font>

因此

单调栈可以轻松的找到下一个更大（更小）的元素

或者能同时找到左边第一个更大和右边第一个更大的元素，用以求面积或容量

栈元素可以是：

- 元素值
- 数组下表





## 优先队列

## 单调队

[239. 滑动窗口最大值 - 力扣（LeetCode）](https://leetcode.cn/problems/sliding-window-maximum/description/)

入队：先将小于自己的元素出队在入队

出队：只出队头且当且仅当要出队的元素等于队头

取最大值：直接读取队头

## 并查集

## 字典树

## 线段树

## 树状数组

## 后缀数组

