



# 1. 协议&编码

**协议格式**

- <font color=red>魔数+编码方式 </font>

  编码协商：新建客户端时向服务端发送**编码格式**报文

- <font color=red>请求头长度+请求头内容+请求体长度+请求体内容 </font>
  - 请求头：请求序号、请求服务和方法、错误信息
  - 请求体：请求参数或者结果参数

**编码和序列化**

- Gob
- protobuf

**通信协议**

TCP

**通信IO模型**

- 服务端

  - one connection one groutine
  - one parsed-header one handler-groutine 

- 客户端

  - one call one groutine with only master receive groutine

    

# 2. 服务方法注册

**方法注册**

<font color=red>反射机制</font>

1. 通过结构体的反射类型，遍历结构体所有的可导出函数

2.   对于每个可导出函数，检查请求参数和返回值的类型和数量是否满足rpc协议的规范

   对于满足规范的函数，将其请求参数的反射类型打包进map，key为方法名

**方法调用**

1. 通过函数名找到参数的反射类型
2. 根据反射类型构建反射对象
3. 反序列化的值设置到参数1中
4. 执行函数，执行结果保留到参数2
5. 序列化参数2作为请求体，发送回客户端

# 3. 超时机制

两种实现途径

- 计时器
- 有超时功能的上下文对象

实现的重点是使用groutine去执行动作（连接、一次远程调用），主协程则同时监控时间管道和动作执行状态管道

如果时间管道先到，则判断为超时



# 4. 注册中心与服务发现

项目使用<font color=red>`etcd`</font>作为注册中心和发现中心

**服务端**

- 当注册服务方法时，同时会向etcd注册。key为服务+方法，value为的IP+端口
- 这个注册行为会绑定一份租约，并且定时向etcd注册中心发送心跳去续约
- 当服务down掉，租约会因为没有续租而过期，这次注册便会被etcd删掉

**客户端**

- 客户端在启动前先从本地服务器列表或向etcd拿到可用的服务器列表
- 同时，客户端有一个watch协程，当新增服务器或者服务端down掉时，etcd会通知这个watch协程，watch协程就可以在本地列表做对应的增删

# 5. 一次rpc调用过程

1. 监听socket、注册服务方法并向etcd注册自己地址
3. 客户端拿到可用的服务器地址
4. 客户端与服务端建立TCP连接
5. 客户端发送一次编码协商请求（也可以每次call的时候将编码方式加入到请求头里）
6. 客户端发起远程调用请求
7. 客户端的编解码器将请求信息（请求序列号、请求方法、请求参数）序列化并通过TCP连接发送到服务端
8. 服务端接收到客户端的请求信息并反序列化
9. 通过请求方法找到对应的接口方法并调用
10. 将响应信息（请求序列号、结果参数、错误信息）序列化响应回客户端
11. 客户端的接收者协程接收到响应信息并反序列化
12. 接收者协程通过请求序列号找到对应的调用者协程提供的通道并把响应结果发送回调用者协程
13. 至此，调用者协程已经拿到了结果和错误信息



# 心得

遇到的问题：偶尔会碰到发出去的请求得不到响应。一开始想会不会是加锁逻辑没有做到幂等，也就是不同的并发顺序会影响加锁结果，可能刚好会导致死锁。简单排查也没有发现问题。然后想那就追踪一些客户端和服务端的数据流动。对于这个想法一开始只是简单的在所有的读和写操作的开始和结束都加上日志打印，然后发现客户端的写请求都成功发送出去了，但是服务端的错误大致是能读到百分之八九十的请求并且成功响应，然后就会阻塞在读tcp报文的函数里。但日志打印的排查粒度太粗了，于是就使用`tcpdump`网络工具去抓包，看两端的tcp通信过程。然后发现客户端发送的所有数据，服务端都ACK了，那证明数据其实是都接收到了，那为什么会丢失一些数据没有处理呢？那一开始的想法是客户端发送速度过快导致服务端的`ringbuf`写满了从而导致最后的几个数据包丢包了，然后就去调大`ringbuf`的`RX`、`TX`，但结果还是一样。但认真tcp的拥塞控制机制，如果发送方发送太快把接收方的`ringbuf`挤满的话，那么接收方会`win`值为零并且通知发送方暂时不要发，所以是不可能出现发送过快而导致最后的那些包丢失，而且抓包发现最后的那些包服务端其实也是回了ACK的，证明数据其实没有丢。最后回头检查自己的协议，客户端和服务端建立连接后的第一个tcp包是用来协商后序远程调用的编码方式的，但是因为服务端处理第一个包的时候没有处理粘包问题，导致在开始处理远程调用的时候已经有一些请求包被错过了。





如果你在使用 Gob 编解码库时遇到第一个报文较长的问题，可能是因为 Gob 在编码数据时会包含类型信息。这个类型信息会导致第一个编码的报文较长，因为它需要包含用于标识类型的额外信息。

Gob 库在序列化数据时，会在第一个报文中包含一个类型信息表，用于映射类型标识符和实际类型。这个表是用于在解码时将类型标识符转换回实际类型。这样的设计使得 Gob 可以在不同程序之间传递自定义类型，而不需要显式地传递类型信息。

由于类型信息表的存在，第一个报文会相对较长。一旦类型信息被发送一次，后续的报文就可以使用更紧凑的格式进行编码。
