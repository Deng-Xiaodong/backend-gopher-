



# 1. 协议&编码

**协议格式**

- <font color=red>魔数+编码方式 </font>

  编码协商：新建客户端时向服务端发送**编码格式**报文

- <font color=red>请求头长度+请求头内容+请求体长度+请求体内容 </font>
  - 请求头：请求序号、请求服务和方法、错误信息
  - 请求体：请求参数或者结果参数

**编码和序列化**

- Gob
- protobuf

**通信协议**

TCP

**通信IO模型**

- 服务端

  - one connection one groutine
  - one parsed-header one handler-groutine 

- 客户端

  - one call one groutine with only master receive groutine

    

# 2. 服务方法注册

**方法注册**

<font color=red>反射机制</font>

1. 通过结构体的反射类型，遍历结构体所有的可导出函数

2.   对于每个可导出函数，检查请求参数和返回值的类型和数量是否满足rpc协议的规范

   对于满足规范的函数，将其请求参数的反射类型打包进map，key为方法名

**方法调用**

1. 通过函数名找到参数的反射类型
2. 根据反射类型构建反射对象
3. 反序列化的值设置到参数1中
4. 执行函数，执行结果保留到参数2
5. 序列化参数2作为请求体，发送回客户端

# 3. 超时机制

两种实现途径

- 计时器
- 有超时功能的上下文对象

实现的重点是使用groutine去执行动作（连接、一次远程调用），主协程则同时监控时间管道和动作执行状态管道

如果时间管道先到，则判断为超时



# 4. 注册中心与服务发现

项目使用<font color=red>`etcd`</font>作为注册中心和发现中心

**服务端**

- 当注册服务方法时，同时会向etcd注册。key为服务+方法，value为的IP+端口
- 这个注册行为会绑定一份租约，并且定时向etcd注册中心发送心跳去续约
- 当服务down掉，租约会因为没有续租而过期，这次注册便会被etcd删掉

**客户端**

- 客户端在启动前先从本地服务器列表或向etcd拿到可用的服务器列表
- 同时，客户端有一个watch协程，当新增服务器或者服务端down掉时，etcd会通知这个watch协程，watch协程就可以在本地列表做对应的增删

# 5. 一次rpc调用过程

1. 监听socket、注册服务方法并向etcd注册自己地址
3. 客户端拿到可用的服务器地址
4. 客户端与服务端建立TCP连接
5. 客户端发送一次编码协商请求（也可以每次call的时候将编码方式加入到请求头里）
6. 客户端发起远程调用请求
7. 客户端的编解码器将请求信息（请求序列号、请求方法、请求参数）序列化并通过TCP连接发送到服务端
8. 服务端接收到客户端的请求信息并反序列化
9. 通过请求方法找到对应的接口方法并调用
10. 将响应信息（请求序列号、结果参数、错误信息）序列化响应回客户端
11. 客户端的接收者协程接收到响应信息并反序列化
12. 接收者协程通过请求序列号找到对应的调用者协程提供的通道并把响应结果发送回调用者协程
13. 至此，调用者协程已经拿到了结果和错误信息

