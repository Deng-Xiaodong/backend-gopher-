# 索引

## 分类

**按物理分类**

- 聚簇索引
- 二级索引

**按字段类型分类**

- 主键索引

- 非主键索引

  - 普通索引

  - 唯一索引（针对值唯一的字段）
  - 前缀索引（针对字符串类型字段）

**按字段数量分类**

- 单列索引
- 联合索引

**聚簇索引VS二级索引**

|          | 叶子节点内容             | I/O情况                                                      |
| -------- | ------------------------ | ------------------------------------------------------------ |
| 聚簇索引 | 整表数据                 |                                                              |
| 二级索引 | 只存放索引列和主键列数据 | **回表**：拿到主键后需要回表到聚簇索引上查找最终数据                     **索引覆盖**：当查询利刚好是索引列和主键列的子集，不需要回表 |

**二级索引VS联合索引**

**索引下推**

二级索引经常性需要回表，恰当对需要查询的列建立联合索引，能避免回表，同时减少表检索I/O（叶子节点小自读读的快，回表需要在聚簇索引的叶子节点检索，那里可是保存了整表）



### 联合索引的最左匹配原则

<font color=red>对于联合索引（a,b)</font>

- a属性列全局有序
- b属性列在a相等的区间内局部有序

**联合索引失效**

`a>1,b>2`：a全局有序，当对于a>1的所有数据，b是无序的，因为为了检索答案需要从满足a>1的第一个数据开始遍历

`a>=1,b>2`：a全局有序，a>1的b无序，但是a=1的b局部有序，因此为了检索答案可以从a=1集合里满足b>2的第一个数据开始遍历



## 使用时机

<font color=red>适合使用</font>

- 查询：经常在`WHERE`被查询的字段。如果查询条件是多个字段可以建立联合索引
- 排序：被`GROUP BY`  和`ORDER BY`修饰的字段。索引树能保证字段在叶子节点上是有序的，这样就不需要再做一次排序

<font color=red>不适合使用</font>

- `WHERE`条件、`GROUP BY` 、`ORDER BY`用不到的字段没必要建索引
- 区分度不高或存在大量重复的字段（如性别）不适合建索引，查询速度退化为O(N)
- 表数据太少
- 频繁更新的字段

## 优化方案

- 覆盖索引
- 防止索引失效
- 主键最好自增

## 为什么B+树



- **平衡二叉查找树**
- **B树**
- **B+树**



`平衡二叉查找树`：当数据量比较多时，平衡二叉查找树的高度始终比B、B+树的高度要高，I/O开销较大

`B树`：非叶子节点存放表数据本身，而每一个大节点是有存储空间大小限制的（page），所有会导致B树每一层的节点总是少于B+树，这样会导致树更高，而且遍历节点时需要额外的I/O去访问无效数据



# 事务



| 事务特性 | 描述                                                         | 保证机制         |
| -------- | ------------------------------------------------------------ | ---------------- |
| 原子性   | 事务中多个（更新）操作要不全做，要不全不做                   | UNDO LOG         |
| 持久性   | 事务的修改是持久的，即便系统down机重启                       | REDO LOG         |
| 隔离性   | 数据库允许多个并发事务同时对数据进行读写请求。隔离性需要保证不同事务互不干扰或者干扰是可预知的 | MVCC或锁         |
| 一致性   | 保证事务执行前后，数据满足完整性约束，数据库保持一致性。（比如无论怎样转账，要保证总额保持不变） | 其他特征共同保证 |

## 隔离性

### 并发事务引发的问题

- 脏读：事务A读到事务B修改但最终可能不提交的数据
- 不可重复度：事务A对同一个自己没有修改的数据的前后两次读不一致
- 幻读：事务A在做布尔查询或统计查询时，前后两次结果不一致

### 事务的隔离级别

- 读未提交：未提交事务的修改能被其他事务可见
- 读提交：提交的事务的修改才能被其他事务可见
- **可重复读**：一个事务内保证对同一个数据的多次读结果跟第一次一致
- 串行化：不同事务满足读写锁约束

### MVCC保证可重复读

- Read View
- 聚簇索引隐藏的事务列

#### Read View

<font color=red>全局事务状态记录表</font>

- m_ids ：指的是在创建 Read View 时，当前数据库中「活跃事务」的**事务 id 列表**，注意是一个列表，**“活跃事务”指的就是，启动了但还没提交的事务**。
- min_trx_id ：指的是在创建 Read View 时，当前数据库中「活跃事务」中事务 **id 最小的事务**，也就是 m_ids 的最小值。
- max_trx_id ：这个并不是 m_ids 的最大值，而是**创建 Read View 时当前数据库中应该给下一个事务的 id 值**，也就是全局事务中最大的事务 id 值 + 1；
- creator_trx_id ：指的是**创建该 Read View 的事务的事务 id**。

。

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/readview%E7%BB%93%E6%9E%84.drawio.png" style="zoom: 67%;" /> <img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB/ReadView.drawio.png" style="zoom: 67%;" />



**InnoDB聚簇索引隐藏列**

<font color=red>回放历史版本的入口</font>

- trx_id，当一个事务对某条聚簇索引记录进行改动时，就会**把该事务的事务 id 记录在 trx_id 隐藏列里**；
- roll_pointer，每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到 undo 日志中，然后**这个隐藏列是个指针，指向每一个旧版本记录**

<img src="https://cdn.xiaolincoding.com//mysql/other/f595d13450878acd04affa82731f76c5.png" style="zoom:80%;" />

**判断当前事务的Read View是否对数据（trx_id）可见**

| trx_id<min_trx_id | min_trx_id<=trx_id<max_trx_id             | trx_id>max_trx_id |
| ----------------- | ----------------------------------------- | ----------------- |
| 可见              | if trx_id in list m_ids：不可见 else 可见 | 不可见            |

### 最大程度解决幻读

- 快照读（普通 select 语句）：Read View 就能解决
- 当前读（select ... for update 等语句）：加锁**（next-key  lock）**。通过锁住当前统计的范围来避免幻读



# 锁

- 全局锁：数据库备份时用到
- 表级锁
  - 表锁
  - **MDL锁**
  - **意向锁**
  - **自增锁**
- 行级锁
  - 记录锁（X,Y REC_NOT_GAP）锁
  - 间隙锁（X,Y GAP）锁
  - **记录锁+间隙锁**（next-key）（X,Y）锁

## 如何加行锁

锁是锁在**索引**上，当查询或修改涉及到**二级索引**，那么二级索引连同聚簇索引都会上锁

**next-key是锁单位**，但也会退化为记录锁或间隙锁

**SQL语句与行锁**

| -SQL                        | -锁                            |
| --------------------------- | ------------------------------ |
| select...                   | 无锁，MVCC提供可重复读隔离级别 |
| select...fin share mode     | S锁                            |
| select...for update         | X锁                            |
| update...  & delete from... | X锁                            |



|            | 等值查询                                                     | 范围查询（<a ）\|\|（ false a）                              | 范围查询（<=a&&true a）                                      | 范围查询（>a）\|\|(false a)                                  | 范围查询（>=a) && (true a)                                   |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 唯一索引   | 存在该值：对该值加记录锁  不存在：对包含该值的最小范围加间隙锁 | 如果不考虑边界值或者边界值不存在，那么==最后一个位置一定大于边界值==，这个位置不用考虑，但左边第一块区域不能被修改，所以锁退化为间隙锁 | 考虑边界值且存在要找的边界值，那么==最后一个位置就在边界值上==，这个位置一定不能被修改且左边第一块区域也一定要考虑，因此保持next-key lock | 不考虑边界值或者不存在要找的边界值，==找到的第一个位置都一定是大于边界值==的，所以需要保证找到的第一个位置是不能修改的，且左边第一个区域也不能被修改，所以保持next-key lock | 考虑边界且存在要找的边界值，那么==找到的第一个位置就是边界值位置==，要保证边界值不能被修改且边界左边不需要考虑，所以==锁退化为记录锁== |
| 非唯一索引 |                                                              |                                                              |                                                              |                                                              |                                                              |
|            |                                                              |                                                              |                                                              |                                                              |                                                              |

### 没有加索引的查询

前面的案例，我们的查询语句都有使用索引查询，也就是查询记录的时候，是通过索引扫描的方式查询的，然后对扫描出来的记录进行加锁。

**如果锁定读查询语句，没有使用索引列作为查询条件，或者查询语句没有走索引查询，导致扫描是全表扫描。那么，每一条记录的索引上都会加 next-key 锁，这样就相当于锁住的全表，这时如果其他事务对该表进行增、删、改操作的时候，都会被阻塞**。

不只是锁定读查询语句不加索引才会导致这种情况，update 和 delete 语句如果查询条件不加索引，那么由于扫描的方式是全表扫描，于是就会对每一条记录的索引上都会加 next-key 锁，这样就相当于锁住的全表。

因此，**在线上在执行 update、delete、select ... for update 等具有加锁性质的语句，一定要检查语句是否走了索引，如果是全表扫描的话，会对每一个索引加 next-key 锁，相当于把整个表锁住了**，这是挺严重的问题。



# 日志



# 内存

